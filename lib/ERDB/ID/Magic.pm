#
# Copyright (c) 2003-2015 University of Chicago and Fellowship
# for Interpretations of Genomes. All Rights Reserved.
#
# This file is part of the SEED Toolkit.
#
# The SEED Toolkit is free software. You can redistribute
# it and/or modify it under the terms of the SEED Toolkit
# Public License.
#
# You should have received a copy of the SEED Toolkit Public License
# along with this program; if not write to the University of Chicago
# at info@ci.uchicago.edu or the Fellowship for Interpretation of
# Genomes at veronika@thefig.info or download a copy from
# http://www.theseed.org/LICENSE.TXT.
#


package ERDB::ID::Magic;

    use strict;
    use warnings;
    use base qw(ERDB::ID);
    use charnames ();

=head1 ERDB Magic Name Helper

This is the ID helper class for magic name IDs. It is a subclass of L<ERDB::ID>, and is used
to insert instances of entities whose ID is generated by text-processing a name field.

This object contains the following fields.

=over 4

=item nameField

Name of the field containing an entity instance's name string.

=back

=head2 Special Methods

=head3 new

    my $helper = ERDB::ID->new($entityName, $loader, $stats, %options);

Construct a new ID helper object for the specified entity.

=over 4

=item entityName

Name of the entity type that this helper generates IDs for.

=item loader

A loader object used to insert records and access the database.

=item stats

A L<Stats> object used for tracking statistics.

=item options

A hash of options, including zero or more of the following.

=over 8

=item exclusive

If TRUE, then it will be presumed we have exclusive access to the database and certain
optimizations will be possible. The default is FALSE, meaning the data can change on us.

=item checkField

If specified, the name of an alternate key field that uniquely identifies entity instances.
This field can be used to determine if an entity instance already exists in the database.
The default is that no such field exists.

=item nameField

The name of the field containing an entity instance's name string.

=back

=back

=cut

sub new {
    # Get the parameters
    my ($class, $entityName, $loader, $stats, %options) = @_;
    # This will be the return value.
    my $retVal;
    # Determine how to construct the object.
    if ($options{exclusive}) {
        $retVal = ERDB::ID::Magic::Exclusive->new($entityName, $loader, $stats, %options);
    } else {
        $retVal = ERDB::ID::Magic::Shared->new($entityName, $loader, $stats, %options);
    }
    # Save the name of the name field.
    $retVal->{nameField} = $options{nameField};
    # Return the object created.
    return $retVal;
}

=head2 Subclass Methods

=head3 Name

    my ($prefix, $suffix) = ERDB::ID::Magic::Name($name);

Compute a magic name from a name string. A magic name is a shortened version of the
name designed to be relatively easy to remember. This involves a lot of fancy
pattern processing.

=cut

use constant LITTLES => { 'and' => 1, 'or' => 1, the => 1, a => 1, of => 1, in => 1, an => 1, to => 1, on => 1 };

sub Name {
    # Get the parameter.
    my ($name) = @_;
    # Translate the Unicode entities.
    while ($name =~ /^(.*?)\&#(\d+)(.+)/) {
        # Extract the unicode entity.
        my ($first, $uni, $last) = ($1, $2, $3);
        # Get its full name. If it has none, just keep the number.
        my $phrase = charnames::viacode($uni) // $uni;
        # Get the last word.
        if ($phrase =~ /(\S+)$/) {
            $uni = $1;
        }
        # Insert the translation.
        $name = "$first $uni $last";
    }
    # Clean what's left and split it into words.
    $name =~ s/\W+/ /g;
    my @words = split /\s+/, $name;
    # Build a string of the words. We stop building at
    # 16 characters. Since we never add more than 4, this
    # means the maximum is 19, leaving 5 digits for
    # uniqueness numbering.
    my $prefix = "";
    while (length($prefix) < 16 && scalar(@words)) {
        my $word = shift @words;
        if ($word =~ /^(\d)$/) {
            # For a number, use the first digit.
            $prefix .= $1;
        } elsif (! LITTLES->{lc $word}) {
            # We ignore common little words. For
            # others, we take the first four characters.
            $prefix .= substr(ucfirst lc $word, 0, 4);
        }
    }
    # The default suffix is none.
    my $suffix = "";
    # Insure we don't end with a digit. If we do, we
    # start with a suffix of 1.
    if ($prefix =~ /\d$/) {
        $prefix .= "n";
        $suffix = 1;
    }
    # Return the prefix and suffix.
    return ($prefix, $suffix);
}


1;
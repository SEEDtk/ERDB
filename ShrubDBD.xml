<?xml version="1.0" encoding="UTF-8"?>
<Database xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:noNamespaceSchemaLocation="http://pubseed.theseed.org/FIG/Html/ERDBtk_DBD.xsd">
    <Title>SEED Bioinformatics Database</Title>
    <Notes>[p]The SEED database manages bio-informatics data imported from
        exchange files. It contains information that can be used to derive
        subsystem spreadsheets and support annotation of genomes. The
        annotation is three-tiered: for each protein, we recognize a
        [i]privileged[/i] annotation, which is curated by a human expert,
        a [i]projected[/i] annotation which is computed by annotation software,
        and a [i]non-priviliged[/i] annotation which is proposed by the
        user
        community.[/p]
        [p]The diagram colors indicate the general category of data.[/p]
        [list]
        [b]Red[/b]
        Genome group: includes all taxonomy and sequence data.[*]
        [b]Blue[/b]
        Annotation group: includes the subsystems and all the functions and
        roles.[*]
        [b]Green[/b] Feature group: includes features, protein sequences,
        and related publications.[*]
        [b]Navy[/b] Chemistry group: includes reactions and compounds.
        [/list]
    </Notes>
    <Regions />
    <Diagram height="800" width="800" ratio="0.7" size="90"
        fontSize="12" editable="0" />
    <Entities>
        <Entity name="Genome" keyType="short-string" default="id name">
            <DisplayInfo theme="red" col="3" row="1" />
            <Notes>A genome represents a specific organism with DNA, or a
                specific meta-genome. All DNA sequences in the database belong to
                genomes.
            </Notes>
            <Fields>
                <Field name="core" type="boolean">
                    <Notes>TRUE if this is a core genome, else FALSE.
                    Annotation data is projected from core genomes.</Notes>
                </Field>
                <Field name="name" type="string">
                    <Notes>Full genus/species/strain name of the genome, occasionally
                        containing notes from the uploader.
                    </Notes>
                </Field>
                <Field name="dna-size" type="counter">
                    <Notes>Number of base pairs in the genome.</Notes>
                </Field>
                <Field name="contigs" type="int">
                    <Notes>Number of contigs for this genome.</Notes>
                </Field>
                <Field name="md5-identifier" type="short-string">
                    <Notes>MD5 identifier for this genome, for comparison with genomes
                        in other databases. The MD5 is computed by taking the MD5s of
                        the contigs, lexically sorting them, joining them together with
                        commas, and computing a hex MD5 of the result.
                    </Notes>
                </Field>
                <Field name="gc-content" type="float">
                    <Notes>Percent GC content present in the genome's DNA.</Notes>
                </Field>
                <Field name="contig-file" type="long-string">
                    <Notes>Name of the file containing the genome's contig FASTA,
                        relative to the repository root.
                    </Notes>
                </Field>
                <Field name="prokaryotic" type="boolean">
                    <Notes>TRUE if this is a prokaryotic genome, else FALSE.</Notes>
                </Field>
                <Field name="domain" type="string">
                    <Notes>Domain for this genome-- Eukaryota, Archaea, Bacteria, etc.</Notes>
                </Field>
                <Field name="genetic-code" type="int">
                    <Notes>Genetic code for translating this genome's coding features to
                    proteins.</Notes>
                </Field>
                <Field name="longest-feature" type="int">
                    <Notes>Length of the longest feature in this genome, used to optimize
                    the genes-in-region function.</Notes>
                </Field>
            </Fields>
            <Indexes>
                <Index>
                    <Notes>This index allows searching for genomes by name.</Notes>
                    <IndexFields>
                        <IndexField name="name" order="ascending" />
                    </IndexFields>
                </Index>
                <Index>
                    <Notes>This index allows searching for genomes by MD5 identifier.
                    </Notes>
                    <IndexFields>
                        <IndexField name="md5-identifier" order="ascending" />
                    </IndexFields>
                </Index>
                <Index>
                    <Notes>This index presents the core genomes first in
                    sequence.</Notes>
                    <IndexFields>
                        <IndexField name="core" order="descending" />
                    </IndexFields>
                </Index>
            </Indexes>
        </Entity>
        <Entity name="Contig" keyType="string" default="id length">
            <DisplayInfo theme="red" col="1" row="1" />
            <Notes>A contig is a contiguous sequence of base pairs belonging to
                a single genome. The key of the contig is the genome ID followed
                by a colon and then the contig ID. The contig's DNA information is
                located in a flat file on disk named "contigs.fa" in the
                directory named by the parent genome.
            </Notes>
            <Fields>
                <Field name="length" type="counter">
                    <Notes>Number of base pairs in the contig.</Notes>
                </Field>
                <Field name="md5-identifier" type="string">
                    <Notes>MD5 identifier of this contig, for comparison with contigs
                        in other databases. This is a standard hex MD5 of the contig
                        DNA sequence.
                    </Notes>
                </Field>
            </Fields>
            <Indexes>
                <Index>
                    <Notes>This index allows searching for contigs by MD5 identifier.
                    </Notes>
                    <IndexFields>
                        <IndexField name="md5-identifier" order="ascending" />
                    </IndexFields>
                </Index>
            </Indexes>
        </Entity>
        <Entity name="Feature" keyType="string" default="id">
            <DisplayInfo theme="green" col="3" row="3" />
            <Notes>A feature (sometimes also called a gene) is a part of a
                genome that is of special interest. Features may be spread across
                multiple DNA sequences (contigs) of a genome, but never across more
                than one genome. Each feature in the database has a unique FIG
                ID that functions as its ID in this table.
            </Notes>
            <Fields>
                <Field name="feature-type" type="short-string">
                    <Notes>Code indicating the type of this feature. Among the
                        codes currently supported are "peg" for a protein encoding
                        gene, "bs" for a binding site, "opr" for an operon, and so
                        forth.
                    </Notes>
                </Field>
                <Field name="sequence-length" type="counter">
                    <Notes>Number of base pairs in this feature.</Notes>
                </Field>
                <Field name="alias" type="string" relation="FeatureAlias">
                    <Notes>An alternative name for the feature. These are frequently
                        ambiguous or incomplete.
                    </Notes>
                </Field>
                <Field name="checksum" type="short-string">
                        <Notes>An MD5 checksum of the feature's original function when it was loaded.
                        This is used to compare it to the original data.</Notes>
                </Field>
            </Fields>
            <Indexes>
                <Index>
                    <Notes>This index is used to find a feature by alias name.</Notes>
                    <IndexFields>
                        <IndexField name="alias" order="ascending" />
                    </IndexFields>
                </Index>
            </Indexes>
        </Entity>
        <Entity name="Protein" keyType="short-string" default="id">
            <DisplayInfo theme="green" col="1" row="3" />
            <Notes>A protein sequence is a specific sequence of amino acids.
                Unlike a DNA sequence, a protein sequence does not belong to a
                genome. Identical proteins generated by different genomes are
                stored as a single Protein instance. The key is a hex MD5
                hash code computed from the protein letter sequence.
            </Notes>
            <Fields>
                <Field name="sequence" type="text">
                    <Notes>The sequence contains the letters corresponding to
                        the protein's amino acids.
                    </Notes>
                </Field>
            </Fields>
        </Entity>
        <Entity name="TaxonomicGrouping" keyType="short-string" default="id scientific-name">
            <Notes>A taxonomic grouping is a segment of the classification for
                an organism. Taxonomic groupings are organized into a strict
                hierarchy by the IsGroupContaining relationship.
            </Notes>
            <Fields>
                <Field name="domain" type="boolean">
                    <Notes>TRUE if this is a domain grouping, else FALSE.</Notes>
                </Field>
                <Field name="hidden" type="boolean">
                    <Notes>TRUE if this is a hidden grouping, else FALSE. Hidden
                        groupings are not typically shown in a lineage list.
                    </Notes>
                </Field>
                <Field name="scientific-name" type="string">
                    <Notes>Primary scientific name for this grouping. This is the name
                        used when displaying a taxonomy.
                    </Notes>
                </Field>
                <Field name="alias" type="string" relation="TaxonomicGroupingAlias">
                    <Notes>Alternate name for this grouping. A grouping
                        may have many alternate names. The scientific name should also
                        be in this list.
                    </Notes>
                </Field>
            </Fields>
            <Indexes>
                <Index>
                    <Notes>This index allows the user to find a particular
                        taxonomic grouping by name. Because the scientifc name is
                        also an alias, there is no index on scientific name.
                    </Notes>
                    <IndexFields>
                        <IndexField name="alias" order="ascending" />
                    </IndexFields>
                </Index>
            </Indexes>
        </Entity>
        <Entity name="Function" keyType="string" default="id description">
            <DisplayInfo theme="blue" row="7" col="3" />
            <Notes>A function is a set of roles that represent the effects of a
                protein. Most functions consist of a single role, but many can have two or three
                roles. The key is the set of role IDs joined by the separator. Thus, a function
                ID is directly computable from its role IDs.
            </Notes>
            <Fields>
                <Field name="description" type="text">
                    <Notes>Text of the function, consisting of the roles strung together
                    in sequence with separator characters in between.</Notes>
                </Field>
                <Field name="sep" type="char">
                    <Notes>Separator character for this function's roles. [b]/[/b] for
                    multiple roles by different domains, [b]@[/b] for multiple
                    roles by the same domain, or [b];[/b] when the function performs
                    one of several roles but the precise one cannot be determined.
                    For a single-function role, a space is used. For a malformed
                    or hypothetical function (which has no roles) a hyphen is used.</Notes>
                </Field>
                <Field name="universal" type="boolean">
                    <Notes>TRUE if this function represents a universal protein, else FALSE</Notes>
                </Field>
            </Fields>
            <Indexes>
                <Index>
                    <Notes>This index is used to find the universal proteins.</Notes>
                    <IndexFields>
                        <IndexField name="universal" />
                        <IndexField name="id" />
                    </IndexFields>
                </Index>
            </Indexes>
        </Entity>
        <Entity name="Role" keyType="short-string" default="id description ec-number">
            <DisplayInfo theme="blue" row="7" col="5" />
            <Notes>A role represents a single effect of a protein in a cell. The
                fundamental	purpose of annotation is to assign roles to proteins.
                The collection of roles (often only one) associated with a protein
                is the protein's function. Each role is assigned a short string key.
                The key is a UUID.
            </Notes>
            <Fields>
                <Field name="description" type="long-string">
                    <Notes>textual description of the role</Notes>
                </Field>
                <Field name="ec-number" type="string">
                    <Notes>EC number of this role (if any)</Notes>
                </Field>
                <Field name="tc-number" type="string">
                    <Notes>transporter classification of this role (if any)</Notes>
                </Field>
                <Field name="hypo" type="boolean">
                    <Notes>TRUE if this is a hypothetical role, else FALSE</Notes>
                </Field>
                <Field name="checksum" type="hash-string">
                    <Notes>Checksum for this role. The role is first normalized by converting
                    it to lower case and removing extra spaces, EC numbers, and TC numbers. Then
                    an MD5 is computed.</Notes>
                </Field>
            </Fields>
            <Indexes>
                <Index unique="1">
                    <Notes>This index allows searching for roles by the checksum string.</Notes>
                    <IndexFields>
                        <IndexField name="checksum" order="ascending" />
                    </IndexFields>
                </Index>
                <Index>
                    <Notes>This index allows searching through roles by EC number.
                    </Notes>
                    <IndexFields>
                        <IndexField name="ec-number" order="ascending" />
                    </IndexFields>
                </Index>
                <Index>
                    <Notes>This index allows searching through roles by TC number.
                    </Notes>
                    <IndexFields>
                        <IndexField name="tc-number" order="ascending" />
                    </IndexFields>
                </Index>
                <Index>
                    <Notes>This index allows searching through roles by text. It can be
                        used with LIKE-style queries to find similar roles.
                    </Notes>
                    <IndexFields>
                        <IndexField name="description" order="ascending" />
                    </IndexFields>
                </Index>
            </Indexes>
        </Entity>
        <Entity name="Subsystem" keyType="short-string" default="id name">
            <DisplayInfo theme="blue" col="7" row="3" />
            <Notes>A subsystem is a collection of roles that work together in a
                cell. Identification of subsystems is an important tool for
                recognizing parallel genetic features in different organisms. The
                key is a short string constructed from the original name.
            </Notes>
            <Fields>
                <Field name="name" type="string">
                    <Notes>The readable name of the subsystem.</Notes>
                    <Asides>The subsystem name used to come in two forms-- a natural form
                        with spaces and an internal form with underscores. In this database
                        we will only have the natural form.
                    </Asides>
                </Field>
                <Field name="privileged" type="boolean">
                    <Notes>TRUE if the subsystem can only be modified by privileged
                    users; FALSE if the subsystem can be modified by anyone.</Notes>
                </Field>
                <Field name="version" type="int">
                    <Notes>Version number for the subsystem. This value is
                        incremented each time the subsystem is backed up.
                    </Notes>
                </Field>
                <Field name="checksum" type="hash-string">
                    <Notes>Checksum for this subsystem, formed from the subsystem
                    name.</Notes>
                </Field>
            </Fields>
            <Indexes>
                <Index unique="1">
                    <Notes>This index allows the user to find the subsystem by name.
                        Note that no two subsystems can have the same name.
                    </Notes>
                    <IndexFields>
                        <IndexField name="name" order="ascending" />
                    </IndexFields>
                </Index>
                <Index unique="1">
                    <Notes>This index allows the user to find the subsystem by checksum.
                    </Notes>
                    <IndexFields>
                        <IndexField name="checksum" order="ascending" />
                    </IndexFields>
                </Index>
                </Indexes>
        </Entity>
        <Entity name="VariantMap" keyType="string" default="variant-code map">
            <DisplayInfo theme="blue" col="7" row="5" caption="Variant\nMap" />
            <Notes>A variant map contains a string defining a set of roles that
            represents an instance of a variant. Any genome that has all roles in
            the set is considered a candidate for the subsystem variant. The
            key is the subsystem ID followed by a colon and a unique identifying
            number.</Notes>
            <Fields>
                <Field name="variant-code" type="string">
                    <Notes>the variant code indicating which form of the subsystem
                        is represented by this set of roles.
                    </Notes>
                </Field>
                <Field name="map" type="text">
                    <Notes>A space-delimited string consisting of a sorted list of
                    role IDs. A genome with all these roles is a candidate for the
                    identified variant.</Notes>
                </Field>
                <Field name="size" type="int">
                    <Notes>Number of roles in this map.</Notes>
                </Field>
            </Fields>
        </Entity>
        <Entity name="SubsystemRow" keyType="string" default="id variant-code">
            <DisplayInfo theme="blue" col="5" row="1" caption="Subsystem\nRow" />
            <Notes>A subsystem row represents an implementation of a subsystem in a genome.
                A genome could conceivably have more than one such implementation
                The key is the subsystem ID followed by a colon and a unique identifying
                number.
            </Notes>
            <Asides>A genome could have multiple instances of a subsystem either
                because they are at different privilege levels (public, privileged,
                or projects) or because the subsystem occurs in different regions of
                the genome (as may be the case when an instance of the the subsystem
                really belongs to a phage). Also note that vacant subsystem rows
                (variant code -1 in SEED) are not stored in this database.</Asides>
            <Fields>
                <Field name="privilege" type="char">
                    <Notes>privilege level of the function assignments from which
                        the subsystem instance was constructed: 0 (public),
                        1 (projected), or 2 (privileged)</Notes>
                </Field>
                <Field name="needs-curation" type="boolean">
                    <Notes>TRUE if the subsystem row needs to be validated or
                        examined for errors. This flag is frequently set when
                        the subsystem row has recently been projected by an automated
                        program.</Notes>
                </Field>
                <Field name="variant-code" type="string">
                    <Notes>the variant code indicating which form of the subsystem
                        is represented by this row.
                    </Notes>
                </Field>
            </Fields>
        </Entity>
        <Entity name="SubsystemCell" keyType="string" default="id">
            <DisplayInfo theme="blue" col="5" row="5" caption="Subsystem\nCell" />
            <Notes>A subsystem cell represents a single role in a subsystem row.
                It contains one or more features from the row's genome. The key is
                the row ID followed by a colon and the role abbreviation.
            </Notes>
        </Entity>
        <Entity name="Complex" keyType="short-string" default="id">
            <DisplayInfo theme="navy" col="7" row="7" />
            <Notes>A complex is a set of chemical reactions that act in concert to
            effect a role.</Notes>
        </Entity>
        <Entity name="Reaction" keyType="short-string" default="id">
            <DisplayInfo theme="navy" col="5" row="9" />
            <Notes>A reaction is a chemical process that converts one set of
            compounds (substrate) to another set (products). The reaction ID is
            generally a small number preceded by a letter. A reversible reaction
            is entered as two separate reactions so that each direction can be
            associated with the appropriate roles.</Notes>
        <Fields>
            <Field name="name" type="string">
                <Notes>Common name of this reaction.</Notes>
            </Field>
            <Field name="direction" type="char">
                <Notes>[b]&gt;[/b] for a normal reaction, [b]&lt;[/b] for a reverse reaction,
                [b]=[/b] for a reversible reaction.</Notes>
            </Field>
        </Fields>
        </Entity>
        <Entity name="Pathway" keyType="string" default="id">
            <DisplayInfo theme="navy" col="3" row="9" />
            <Notes>A pathway is a sequence of reactions that work together.</Notes>
            <Fields>
                <Field name="type" type="short-string">
                    <Notes>General type of the pathway, e.g. MetaCyc, KEGG.</Notes>
                </Field>
            </Fields>
        </Entity>
        <Entity name="Compound" keyType="string" default="id label">
            <DisplayInfo theme="navy" col="7" row="9"/>
            <Notes>A compound is a chemical that participates in a reaction. All compounds
                have a unique ID and may also have one or more names. Both ligands and
                reaction components are treated as compounds.
            </Notes>
            <Fields>
                <Field name="label" type="string">
                    <Notes>Primary name of the compound.</Notes>
                </Field>
                <Field name="formula" type="string">
                    <Notes>Formula used to write the compound in reactions.</Notes>
                </Field>
                <Field name="cofactor" type="boolean">
                    <Notes>TRUE if this compound is found in most reactions, else FALSE</Notes>
                </Field>
            </Fields>
            <Indexes>
                <Index>
                    <Notes>This index allows searching for compounds by name.</Notes>
                    <IndexFields>
                        <IndexField name="label" order="ascending"/>
                    </IndexFields>
                </Index>
            </Indexes>
        </Entity>
        <Entity name="Cluster" keyType="counter" default="id" autocounter="1">
            <DisplayInfo theme="blue" col="5" row="3" />
            <Notes>A cluster is a set of features that belong to the same subsystem row and
            are physically close together on the genome. Each cluster has an ID code.</Notes>
        </Entity>
        <Entity name="CddDomain" keyType="string" default="id">
            <DisplayInfo theme="green" col="1" row="7" caption="CDD Domain" />
            <Notes>A domain is a protein domain from the Conserved Domain Database. The ID is the
            CDD identifier.</Notes>
        </Entity>
        <Entity name="ProteinFamily" keyType="short-string" default="id">
            <DisplayInfo theme="green" col="2" row="5" caption="Protein\nFamily" />
            <Notes>A protein family contains a set of proteins that perform the same function.</Notes>
        </Entity>
        <Entity name="SubsystemClass" keyType="string" default="id">
            <DisplayInfo theme="blue" col="7" row="1" caption="Subsystem\nClass" />
            <Notes>A subsystem class defines a general category of subsystem.</Notes>
        </Entity>
    </Entities>
    <Relationships>
        <Relationship name="Class2SubClass" from="SubsystemClass" to="SubsystemClass" arity="1M"
            converse="Class2SupClass">
            <DisplayInfo theme="blue" fixed="1" col="6" row="1" caption="Class to\nSubClass" />
            <Notes>This relationship connects a subsystem class to the smaller classes that subdivide it.</Notes>
        </Relationship>
        <Relationship name="Class2Subsystem" from="SubsystemClass" to="Subsystem" arity="1M"
            converse="Subsystem2Class">
            <DisplayInfo theme="blue" caption="Class to\nSubsystem" />
            <Notes>This relationship connects a bottom-level subsystem class to its subsystems.</Notes>
        </Relationship>
        <Relationship name="Family2Protein" from="ProteinFamily" to="Protein" arity="MM"
            converse="Protein2Family">
            <DisplayInfo theme="green" col="2" row="4" fixed="1" caption="Protein\nto Family" />
            <Notes>This relationship determines a protein's membership in a family.</Notes>
        </Relationship>
        <Relationship name="Function2Family" from="Function" to="ProteinFamily" arity="1M"
            embedded="1" converse="Family2Function">
            <DisplayInfo theme="green" col="2" row="6" fixed="1" caption="Family to\nFunction" />
            <Notes>This relationship connects a protein family to the function it represents.</Notes>
        </Relationship>
        <Relationship name="Cluster2Feature" from="Cluster" to="Feature" arity="MM"
            converse="Feature2Cluster">
            <DisplayInfo theme="blue" caption="Cluster to\nFeature" />
            <Notes>This relationship connects a cluster to the features that comprise it.</Notes>
        </Relationship>
        <Relationship name="Row2Cluster" from="SubsystemRow" to="Cluster" arity="1M"
            converse="Cluster2Row" embedded="1">
            <DisplayInfo theme="blue" caption="Row to\nCluster" />
            <Notes>This relationship connects a cluster to the single subsystem row its features
            occupy.</Notes>
        </Relationship>
        <Relationship name="Domain2Protein" from="CddDomain" to="Protein" arity="MM"
            converse="Protein2Domain">
            <DisplayInfo theme="green" caption="Protein to\nDomain" />
            <Notes>This relationship connects a protein sequence to the primary CDD domains
            associated with it. This information is used to verify the protein's role.</Notes>
        </Relationship>
        <Relationship name="Domain2Role" from="CddDomain" to="Role" arity="MM"
            converse="Role2Domain">
            <DisplayInfo theme="blue" caption="Domain\nto Role" fixed="1" col="3" row="8" />
            <Notes>This relationship connects a role to the primary CDD domains associated with it.
            There will generally be at most two.</Notes>
        </Relationship>
        <Relationship name="IsTaxonomicGroupOf" from="TaxonomicGrouping"
            to="TaxonomicGrouping" arity="1M" converse="IsInTaxonomicGroup"
            embedded="1">
            <Notes>This relationship imposes a hierarchy on taxonomic groupings.
                Each group can contain one or more subgroups. A group with no
                subgroups is a leaf. There is a hidden root group at the top.
                The subgroups of that group are domains.
            </Notes>
        </Relationship>
        <Relationship name="Taxonomy2Genome" from="TaxonomicGrouping"
            to="Genome" arity="1M" converse="Genome2Taxonomy" embedded="1">
            <Notes>This relationship connects a genome to the taxonomic group to
                which it belongs. The taxonomic group is computed from the genome
                ID where possible, and the genome name otherwise. It can also be
                specified explicitly in the genome exchange files.
            </Notes>
            <Fields>
                <Field name="confidence" type="char">
                    <Notes>This indicates how confident we are in the taxonomic
                    assignment. A value of [b]2[/b] means there is an exact
                    match on name or genome ID. A value of [b]1[/b] means there
                    was a close match near the node chosen. A value of [b]0[/b]
                    means we had to guess.</Notes>
                </Field>
            </Fields>
        </Relationship>
        <Relationship name="Genome2Feature" from="Genome" to="Feature"
            arity="1M" converse="Feature2Genome" embedded="1">
            <DisplayInfo theme="green" caption="Genome to\nFeature" />
            <Notes>This relationship connects a genomes to the points of
            interest (features) in its DNA.</Notes>
        </Relationship>
        <Relationship name="Protein2Feature" from="Protein" to="Feature"
            arity="1M" converse="Feature2Protein" embedded="1">
            <DisplayInfo theme="green" caption="Feature\nto Protein" />
            <Notes>This relationship connects a feature to its protein
            translation.</Notes>
        </Relationship>
        <Relationship name="Feature2Contig" from="Feature" to="Contig"
            arity="MM" converse="Contig2Feature">
            <DisplayInfo theme="green" caption="Contig to\nFeature" />
            <Notes>This relationship connects a feature to the DNA segments
            that comprise it. Normally there is only one such segment, but
            eukaryotes will tend to have features with multiple segments.</Notes>
            <Fields>
                <Field name="ordinal" type="int">
                  <Notes>Sequence number of this segment, starting from 0
                  and proceeding sequentially forward from there.</Notes>
                </Field>
                <Field name="begin" type="int">
                  <Notes>Index (1-based) of the first residue in the contig
                  that belongs to the segment.</Notes>
                  <Asides>The begin value is not the start residue, it is the
                  leftmost residue. If the direction is backward, it will
                  actually be the end residue.</Asides>
                </Field>
                <Field name="len" type="int">
                  <Notes>Length of this segment.</Notes>
                </Field>
                <Field name="dir" type="char">
                  <Notes>Direction (strand) of the segment: [b]+[/b] if it is
                  forward and [b]-[/b] if it is backward.</Notes>
                </Field>
            </Fields>
            <FromIndex unique="1">
                <Notes>This index presents the segments of the feature in the correct
                order.</Notes>
                <IndexFields>
                    <IndexField name="ordinal" order="ascending" />
                </IndexFields>
            </FromIndex>
            <ToIndex>
                <Notes>This index presents the segments on a contig in order of the
                start position.</Notes>
                <IndexFields>
                    <IndexField name="begin" order="ascending" />
                    <IndexField name="len" order="descending" />
                </IndexFields>
            </ToIndex>
        </Relationship>
        <Relationship name="Function2Role" from="Function" to="Role"
            arity="MM" converse="Role2Function">
            <DisplayInfo theme="blue" caption="Function\nto Role" />
            <Notes>This relationship connects a function to its constituent
            roles. Most functions consist of a single role, but some can
            connect to several roles.</Notes>
        </Relationship>
        <Relationship name="Subsystem2Role" from="Subsystem" to="Role"
            arity="MM" converse="Role2Subsystem">
            <DisplayInfo theme="blue" caption="Subsystem\nto Role" />
            <Notes>This relationship connects a subsystem to its constituent
            roles. The relationship specifies the role abbreviation and its
            ordinal position in the subsystem path.</Notes>
            <Fields>
                <Field name="ordinal" type="int">
                    <Notes>Ordinal position of this role (from 0) in the columns
                        of the populated subsystem</Notes>
                </Field>
                <Field name="abbr" type="string">
                    <Notes>Abbreviation for the subsystem role name.</Notes>
                </Field>
                <Field name="aux" type="boolean">
                    <Notes>TRUE if this is an auxiliary role</Notes>
                </Field>
            </Fields>
            <FromIndex>
                <Notes>This index presents the roles in pathway order.</Notes>
                <IndexFields>
                    <IndexField name="ordinal" order="ascending" />
                </IndexFields>
            </FromIndex>
        </Relationship>
        <Relationship name="Genome2Contig" from="Genome" to="Contig"
            arity="1M" converse="Contig2Genome" embedded="1">
            <DisplayInfo theme="red" caption="Genome\nto Contig" />
            <Notes>This relationship connects a genome to its constituent
            contigs. The full set of contigs comprises the DNA sequence
            of the genome.</Notes>
        </Relationship>
        <Relationship name="Feature2Function" from="Feature" to="Function"
            arity="MM" converse="Function2Feature">
            <DisplayInfo theme="blue" caption="Feature\nto Function" />
            <Notes>This relationship connects a feature to its function.
            Only features which do not produce proteins will be connected
            to functions, as the primary function assignment is to
            proteins.</Notes>
            <Fields>
                <Field name="security" type="char">
                    <Notes>Privilege level of the annotation. [b]0[/b] for a
                    non-privileged (public) annotation, [b]1[/b] for a projected
                    annotation, and [b]2[/b] for a privileged annotation.</Notes>
                </Field>
                <Field name="comment" type="text">
                    <Notes>A comment by the annotator about this functional
                    assignment.</Notes>
                </Field>
            </Fields>
            <FromIndex unique="1">
                <Notes>This index insures only one function of each privilege is assigned
                to a feature.</Notes>
                <IndexFields>
                    <IndexField name="security" order="descending" />
                </IndexFields>
            </FromIndex>
            <ToIndex>
                <Notes>This index speeds queries that restrict to specific genomes.</Notes>
                <IndexFields>
                     <IndexField name="security" order="descending" />
                     <IndexField name="from-link" order="ascending" />
                </IndexFields>
            </ToIndex>
        </Relationship>
        <Relationship name="Role2Complex" from="Role" to="Complex"
            arity="MM" converse="Complex2Role">
            <DisplayInfo theme="navy" caption="Role to\nComplex" />
            <Notes>This relationship connects a role to the complexes that
            take place when the role is expressed.</Notes>
            <Fields>
                <Field name="triggering" type="boolean">
                    <Notes>TRUE if the presence of the role is sufficient to trigger
                    the complex, else FALSE.</Notes>
                </Field>
            </Fields>
        </Relationship>
        <Relationship name="Complex2Reaction" from="Complex" to="Reaction"
            arity="MM" converse="Reaction2Complex">
            <DisplayInfo theme="navy" caption="Complex to\nReaction" />
            <Notes>This relationship connects a complex to its constituent
            reactions.</Notes>
        </Relationship>
        <Relationship name="Pathway2Reaction" from="Pathway" to="Reaction"
            arity="MM" converse="Reaction2Pathway">
            <DisplayInfo theme="navy" caption="Pathway\nto Reaction" />
            <Notes>This relationship connects a pathway to its constituent
            reactions.</Notes>
        </Relationship>
        <Relationship name="Reaction2Compound" from="Reaction" to="Compound"
            arity="MM" converse="Compound2Reaction">
            <DisplayInfo theme="navy" caption="Reaction to\nCompound" />
            <Notes>This relationship connects a reaction to the compounds that
                participate in it. A reaction involves many compounds, and a
                compound can be involved in many reactions. The relationship
                attributes indicate whether a compound is a product or substrate of
                the reaction, as well as its stoichiometry.
            </Notes>
            <Fields>
                <Field name="product" type="boolean">
                    <Notes>TRUE if the compound is a product of the reaction,
                        FALSE if it is a substrate. When a reaction is written on
                        paper in chemical notation, the substrates are left of the
                        arrow and the products are to the right. Sorting on this
                        field will cause the substrates to appear first, followed by
                        the products.
                    </Notes>
                </Field>
                <Field name="stoichiometry" type="float">
                    <Notes>Number of molecules of the compound that participate
                        in a single instance of the reaction. For example, if a
                        reaction produces two water molecules, the stoichiometry of
                        water for the reaction would be two. When a reaction is
                        written on paper in chemical notation, the stoichiometry is
                        the number next to the chemical formula of the
                        compound.
                    </Notes>
                </Field>
            </Fields>
            <ToIndex>
                <Notes>This index presents the compounds in the reaction in the
                    order they should be displayed when writing it in chemical
                    notation. All the substrates appear before all the products.
                </Notes>
                <IndexFields>
                    <IndexField name="product" order="ascending" />
                </IndexFields>
            </ToIndex>
        </Relationship>
        <Relationship name="Genome2Row" from="Genome" to="SubsystemRow"
            arity="1M" converse="Row2Genome" embedded="1">
            <DisplayInfo theme="blue" caption="Genome\nto Row" />
            <Notes>This relationship connects a subsystem row to the
                genome which it populates. A subsystem's occurrence
                in a genome is only represented if it is considered
                relatively important for annotation analysis and projection.
            </Notes>
        </Relationship>
        <Relationship name="Feature2Cell" from="Feature" to="SubsystemCell"
            arity="MM" converse="Cell2Feature">
            <DisplayInfo theme="blue" caption="Feature\nto Cell" />
            <Notes>This relationship connects a feature to the subsystem
                spreadsheet cells it occupies.</Notes>
        </Relationship>
        <Relationship name="Subsystem2Row" from="Subsystem" to="SubsystemRow"
            arity="1M" converse="Row2Subsystem" embedded="1">
            <DisplayInfo theme="blue" caption="Row to\nSubsystem" />
            <Notes>This relationship connects a subsystem to its populated
                spreadsheet rows. Each row represents the implementation
                of a subsystem in a genome by particular features. Thus,
                this relationship connects a subsystem to its implementations
                of interest.
            </Notes>
        </Relationship>
        <Relationship name="Subsystem2Map" from="Subsystem" to="VariantMap"
            arity="1M" converse="Map2Subsystem" embedded="1">
            <DisplayInfo theme="blue" caption="Subsystem\nto Map" />
            <Notes>This relationship connects a subsystem to its variant maps.
            The full set of variant maps can be used to easily project a subsystem
            into a set of roles.
            </Notes>
        </Relationship>
        <Relationship name="Row2Cell" from="SubsystemRow" to="SubsystemCell"
            arity="1M" converse="Cell2Row" embedded="1">
            <DisplayInfo theme="blue" caption="Row to\nCell" fixed="1" row="3" col="6" />
            <Notes>This relationship yields all the cells (one per role) in
                a subsystem spreadsheet row.
            </Notes>
            <Fields>
                <Field name="ordinal" type="int">
                    <Notes>ordinal position (0-based) of this cell's role in
                        the subsystem's role list</Notes>
                </Field>
            </Fields>
            <FromIndex>
                <Notes>This index presents the cells of a subsystem row in role
                    order.</Notes>
                <IndexFields>
                    <IndexField name="ordinal" order="ascending" />
                </IndexFields>
            </FromIndex>
        </Relationship>
        <Relationship name="Role2Cell" from="Role" to="SubsystemCell"
            arity="1M" converse="Cell2Role" embedded="1">
            <DisplayInfo theme="blue" caption="Cell to\nRole" />
            <Notes>This relationship connects a subsystem cell to the role
                its features perform.
            </Notes>
        </Relationship>
    </Relationships>
</Database>
